import numpy as np

# Scenario matrix
y=np.array([[1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0], [0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                 [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]], dtype=int)
# Given data
Sb = 100
Vb = 12.66
Zb = (Vb ** 2) * 1000 / Sb
P0 = np.array([[0], [100], [90], [120], [60], [60], [200], [200], [60], [60], [45], [60], [60], [60], [120], [60], [60], [60], [80], [90], [90], [90], [90], [420], [420], [60], [60], [60], [120], [200], [150], [210], [60]], dtype=float) # Initial active power
Q0 = np.array([[0], [60], [40], [80], [30], [20], [199], [100], [20], [20], [30], [35], [35], [80], [10], [20], [29], [40], [40], [40], [40], [40], [50], [200], [200], [25], [25], [20], [70], [600], [70], [100], [40]], dtype=float) # Initial reactive power
Z0 = np.diag([0.0 + 0.0j, 0.0922 + 0.0470j, 0.4930 + 0.2511j, 0.3660 + 0.1864j, 0.38114 + 0.1941j, 0.8190 + 0.7070j, 0.1872 + 0.6188j, 0.7114 + 0.2351j, 1.0300 + 0.7400j, 1.0440 + 0.7400j, 0.1966 + 0.0650j, 0.3744 + 0.1238j, 1.4680 + 1.1550j, 0.5416 + 0.7129j, 0.5910 + 0.5260j, 0.7463 + 0.5450j, 1.2890 + 1.7210j, 0.7320 + 0.5740j, 0.1640 + 0.1865j, 1.5042 + 1.3554j, 0.4085 + 0.4784j, 0.7089 + 0.9373j, 0.4512 + 0.3083j, 0.89804 + 0.7091j, 0.8960 + 0.7011j, 0.2030 + 0.1034j, 0.2842 + 0.1447j, 1.0590 + 0.9337j, 0.8042 + 0.7006j, 0.5075 + 0.2585j, 0.9740 + 0.9630j, 0.3105 + 0.3619j, 0.3410 + 0.5302j]) # Impedance matrix

Vslack = np.ones((33, 1), dtype=complex)

# Generate scenarios
def generate_scenarios(n):
    return np.array([list(map(int, format(i, f'0{n}b'))) for i in range(2**n)])

n_interrupteurs = 16
matrice_scenarios = generate_scenarios(n_interrupteurs)
nombre_scenarios = len(matrice_scenarios)

# Calculate A matrix using the scenario matrix
def calculate_A_matrix(y):
    A = y.copy()
    while True:
        prev_A = A.copy()
        A = np.dot(A, A)
        A = np.where(A > 0, 1, 0)
        if np.array_equal(A, prev_A):
            break
    return A

A = calculate_A_matrix(y)

# Calculate ZA matrix using A and Z0
ZA = np.dot(A.T, np.abs(Z0) / Zb)

# Calculate initial P and Q values
P = P0 / Sb
Q = Q0 / Sb

# Calculate Ibus and Ibranche for initial values
Ibus = np.conj((P + 1j * Q) / Vslack)
Ibranche = np.dot(A, Ibus)

# Pre-calculate the loss coefficients
Ibranche_squared = np.abs(Ibranche)**2
Ploss_coeff = Ibranche_squared * np.real(Z0) / Zb
Qloss_coeff = Ibranche_squared * np.imag(Z0) / Zb

# Arrays to store results
V_S = np.zeros((nombre_scenarios, 1), dtype=float)
Ploss_S = np.zeros((nombre_scenarios, 1), dtype=float)
Qloss_S = np.zeros((nombre_scenarios, 1), dtype=float)

# Loop through scenarios
for s, scenario in enumerate(matrice_scenarios):
    # Apply scenario changes to A matrix
    for i in range(16):
        A[i * 2 + 1][i * 2 + 2] = scenario[i]

    k = 1
    erreur = 1
    V = Vslack.copy()
    while erreur > 0.0001 and k < 40:
        Ibus = np.conj((P + 1j * Q) / V)
        Ibranche = np.dot(A, Ibus)
        DV = np.dot(ZA, Ibranche)
        V = Vslack - DV
        erreur = np.max(np.abs(Vslack) - np.abs(V))
        k += 1

    V_S[s] = np.sum((1 - np.abs(V))**2) / 33

    # Calculate power losses for the current scenario
    Ploss_S[s] = np.sum(Ibranche_squared * Ploss_coeff) * Sb
    Qloss_S[s] = np.sum(Ibranche_squared * Qloss_coeff) * Sb

    #print('scenario :', s, V_S[s], Ploss_S[s], Qloss_S[s])

print("Nombre de scÃ©narios :", nombre_scenarios)
